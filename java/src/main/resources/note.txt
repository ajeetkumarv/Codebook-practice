Java is pass by referenc or pass by value
    https://www.youtube.com/watch?v=-5NC5_sI-vQ

What is a POJO
    https://www.youtube.com/watch?v=oqPiEc2zNb0&list=WL&index=2&t=2s
    1) Can't extend or implement anything
    2) No external annotation

    this is usable itself without anything external

What is Java Bean
    https://www.youtube.com/watch?v=oqPiEc2zNb0&list=WL&index=2&t=2s
    1) has private members
    2) has no-args constructor (implicit is ok)
    3) has public getters and setters
    4) Must be serializable

Why Strings are Immutable
    https://www.youtube.com/watch?v=Bj9Mx_Lx3q4&list=WL&index=9
    https://stackoverflow.com/questions/390703/what-is-the-purpose-of-the-expression-new-string-in-java#:~:text=Initializes%20a%20newly%20created%20String,unnecessary%20since%20Strings%20are%20immutable.
    http://kjetilod.blogspot.com/2008/09/string-constructor-considered-useless.html
    new String() is actually Implementation Dependent, like Apache Harmony has different

Immutable classes in java
    Wrapper classes, String, LocalDateTime

Map contract
    1) if two objects are equals, must have same hashCode
    2) if hashCode is same, equals may not be same

Use least specific interface, this makes intentions clear and provides only what you need.

A fail-fast system doesn't continue with errors. it stops immediately. fail-safe are opposite bcz they work on the clone of data.
Fail-fast iterations => ConcurrentModificationException
Fail-safe iterations => NO ConcurrentModificationException

Streams
    Streams lets you process data in a expressive way. we can write code that is declarative, composable, parallelizable.
    It's an object on which we can define operations
    it doesn't change the data it processes.
    All the methods of stream that return stream are lazy

Lambda
    it's an object without Identity
    it is to be looked as block of code that can be moved around, not as a object on which we invoke methods.
    Types of lambda expression is FunctionalInterface

Duration => Hours, minutes, Seconds
Period => Year, month, days

In Normal case we use garbasge variable. it only purpose is to act as an intermediate throwaway container. in java 8 this
implementation detail is pushed into the library where it belongs.

Default methods helped evolve interfaces non intrusively

final
    As a programmer, I'd better know what i want to do, declaring intent and having the compiler enforce it on my behalf
    is a good thing.

Non-Reifiable Types
A reifiable type is a type whose type information is fully available at runtime. This includes primitives, non-generic types, raw types, and invocations of unbound wildcards.

Non-reifiable types are types where information has been removed at compile-time by type erasure — invocations of
    generic types that are not defined as unbounded wildcards. A non-reifiable type does not have all of
    its information available at runtime. Examples of non-reifiable types are List<String> and List<Number>;
    the JVM cannot tell the difference between these types at runtime. As shown in Restrictions on Generics,
    there are certain situations where non-reifiable types cannot be used: in an instanceof expression,
    for example, or as an element in an array.
    https://docs.oracle.com/javase/tutorial/java/generics/nonReifiableVarargsType.html#:~:text=A%20reifiable%20type%20is%20a,is%20fully%20available%20at%20runtime.&text=Non%2Dreifiable%20types%20are%20types,not%20defined%20as%20unbounded%20wildcards.

Heap Pollution (More on above link)
    Heap pollution occurs when a variable of a parameterized type refers to an object that is not of that parameterized type.
    This situation occurs if the program performed some operation that gives rise to an unchecked warning at compile-time.

Defensive copy
    is a technique to mitigate -ve effects of unintensional modifications of shared objects.

Immutability Advantages
    Simple to create, test, and use
    Automatically thread safe and have no synchronization issues
    Allow hashCode cache
    don't need to be defensively copied
    Don't need a copy constructor

Joshua Bloch
    Classes should be immutable unless there is a good reason to make them mutable. if not possible, limit their ability to mutate

Aggregation vs Composition
    Types can exist without car
    Room can't be without house (walls)

    Composition is strong association
    Aggregation is weak association

    Composition is part-of
    Aggregation is has-a

Lambda expression vs Annonymous class
    Ann class is for class declaration and Lambda is for method body
    Ann class generates an extra class wit $ and lambda uses invoke dynamics
    Ann class this represents ann class, this inside lambda refers to class
    Ann class can be used for > 1 abstract method, lambda only for SAM

Invoke Dynamics (Since 7)
    It is a new JVM instruction (opcode) which allows a compiler to generate code which calls
    methods with a looser specification than was previously possible --
    if you know what "duck typing" is, invokedynamic basically allows for duck typing.
    There's not too much you as a Java programmer can do with it; if you're a tool creator,
    though, you can use it to build more flexible, more efficient JVM-based languages.

    Before Java 7, the JVM only had four method invocation types:
    invokevirtual to call normal class methods,
    invokestatic to call static methods,
    invokeinterface to call interface methods, and
    invokespecial to call constructors or private methods.

-XX:+UseStringDeduplication
    StringDeduplicationAgeThreshold JVM setting default value 3
    -XX:+CompactStrings since java 9 on by default
    https://stackoverflow.com/questions/42080648/why-when-you-would-not-want-to-have-java-8-usestringdeduplication-enabled-in-jvm

https://stackoverflow.com/questions/586363/why-is-super-super-method-not-allowed-in-java?rq=1

    serial,
        Stop the world, single thread to GC
    parallel, default in <= Java 8 also known as throughput collector
        Stop the world, parallel threads to GC
    CMS, removed in 14.
        It's designed to eliminate the long pause associated with the full gc of parallel & serial collector.
        It use 1 or more gc threads to scan the old generation periodically, and discard unused objects,
        the pause is very short, but use more cpu time.
    G1GC,
        It's low pause / server style gc, mainly for large heap (> 4Gb).
        divides old gen into parts, clean old gen by copy from 1 part to another. thus less fragmented
    ZGC
    Shenandoah

Default garbage collectors:
    Java 7 - Parallel GC
    Java 8 - Parallel GC
    Java 9 - 15 - G1 GC
    -XX:+UseG1GC or -XX:+UseConcMarkSweepGC.

    https://stackoverflow.com/questions/33206313/default-garbage-collector-for-java-8
    https://backstage.forgerock.com/knowledge/kb/article/a75965340
    Parallel is also known as Throughput collector
    JEP 248: Make G1 the Default Garbage Collector
        http://openjdk.java.net/jeps/248
    https://docs.oracle.com/en/java/javase/11/gctuning/z-garbage-collector1.html#GUID-A5A42691-095E-47BA-B6DC-FB4E5FAA43D0

    https://www.baeldung.com/jvm-epsilon-gc-garbage-collector
    Epsilon GC or No-Op GC
    Algos
            Mark copy
            Mark Sweep

    Throuput
        avg time spent running code and running GC
        so 99% throuput means GC running 1% of time

    Generational Hypothesis
        Young Generation
        Old Generation
            Mark-Sweep-Compaction
    https://www.youtube.com/watch?v=2AZ0KKeXJSo Defog
    Ranjith ramachandran
    https://www.youtube.com/watch?v=UnaNQgzw4zY
        when -XX:MaxTenuringThreshold is reachied (i think 16) then objects are moved to old gen
    Minor run of GC in on Young Gen only
    Major run of GC goes through all spaces

jagged arrays

Before JDK 7, the pool was part of permgen space, and from JDK 7 to now, it is part of the main heap memory.

Thread is a worker, Runnable is the Job
Thread class itself implements Runnable
Once the thread is started, it can’t be started again.

Rob Pike
    https://rakhim.org/summary-of-concurrency-is-not-parallellism-a-talk-by-rob-pike/
    Parallelism is *doing* lot of things at once
    Concurrency is about *dealing* with a lot of things at once.

    The ideas are, obviously, related, but one is inherently associated with structure, the other is associated with execution.
    Concurrency is structuring things in a way that might allow parallelism to actually execute them simultaneously.
    But parallelism is not the goal of concurrency. The goal of concurrency is good structure.

https://www.baeldung.com/java-singleton
https://www.baeldung.com/java-singleton-double-checked-locking
    Conceptually, a singleton is a kind of global variable.
    In general, we know that global variables should be avoided — especially if their states are mutable.

https://wiki.sei.cmu.edu/confluence/display/java/TSM03-J.+Do+not+publish+partially+initialized+objects#:~:text=The%20Java%20memory%20model%20(JMM,publication%20of%20partially%20initialized%20objects.
https://stackoverflow.com/questions/45857765/partial-constructed-objects-in-the-java-memory-model
https://wiki.sei.cmu.edu/confluence/display/java/OBJ11-J.+Be+wary+of+letting+constructors+throw+exceptions


Since Java 16 it is possible
Regular Inner class can't have static declarations for members
Technically there I don't know of any reason why the language restricts the use of static elements for inner classes.
A nonstatic inner class can be emulated by using a normal class that takes the (formerly) enclosing instance as an
argument to the constructor. Of course there are many little differences when it comes to visibility rules an visibility scopes.

I presume it was a language design decision, mostly because statics in non-static inner classes
are confusing and non-intuitive to access (Outer.Inner.StaticMember).

Spliterator
  // Obtain a Spliterator.
  Spliterator<String> splitItr = myStream.spliterator();
  // Iterate the elements of the stream.
  while(splitItr.tryAdvance((n) -> System.out.println(n)));
  splitItr.forEachRemaining(n -> sout);

  Spliterator<String> splitItr = myStream.spliterator();
      // Now, split the first iterator.
      Spliterator<String> splitItr2 = splitItr.trySplit();
       // If splitItr could be split, use splitItr2 first.
      if(splitItr2 != null) {
        System.out.println("Output from splitItr2: ");
        splitItr2.forEachRemaining((n) -> System.out.println(n));
      }
      // Now, use the splitItr.
      System.out.println("\nOutput from splitItr: ");
      splitItr.forEachRemaining((n) -> System.out.println(n));

SynchronousQueue
    Direct Handoff or Size of 1(not really)
    No peek method
    no Iterate
    only for handoffs

    It requires consumer thread to be ready so that it can handoff directly

Collectors
    .toList
    .toMap
    .toSet
    .toUnmodifiableList
    .toUnmodifiableSet
    .toUnmodifiableMap
    .toConcurrentList
    .toConcurrentMap

Check Teeing in collectors this came with Java 12
if means collector, collector, combineThoseCollectors

https://www.baeldung.com/java-8-collectors


https://www.falkhausen.de/Java-10/java.util/Exceptions.html
https://rollbar.com/blog/java-exceptions-hierarchy-explained/

ZipError indicates a low-level JVM error and, although you may catch it just like any other exception,
there is a chance that the whole JVM is at that moment in such a state that it shouldn't continue to run.
Note that there is a separate ZipException for more regular sort of errors, like corrupt files, I/O errors etc.

Error
    ServiceConfigurationError (1.6)
    VirtualMachineError (CitiusTech - when SQLServer was taking 97% and error was Unable to create Java Virtual Machine)
        UnknownError
        InternalError
            ZipError (1.6)



 Short, Self Contained, Correct (Compilable), Example (also known as an SSCCE).
Mutable states problems
    Error prone
    hard to reason
    hard to make concurrent
Higher Order Function means
we can pass Function to Function
we can create Function within Function
we can return Function from Function

Functions have to be pure, they don't have side effects
1. does not change anything
2. does not depend of anything that changes

Imperative vs Declarative
how             what
Mutate          transform
side-effects    pure
pass objects    pass Function also
hard to compose Functional composition

java -p => module path
java -f output/second.jar -d => will tell you the name

Everything in the class path goes for Unnamed module
Automatic module is old jar coming to life in module path
Explicitly named module are new stuff in the module path.- has module descriptor

if function is pure, compiler can use referencial transparancy ie. if a and b are final then usage of a + b can be
replaced by their values added, so runs faster

Builder pattern is also known as Train reck pattern or cascade pattern


there 5 types of lambda
static Integer::parseInt
bound the one capturing state eg. Instance.now()::isAfter
unbound String::toLowerCase
class constructor LinkedList::new
Array constructor int[]:: new

there are 43 standard function Interfaces
6 are basic.


parallelization is optimization, treat it like any other optimization

we don't come up with new things, we just come up with new names of same things and get very excited about it.
You can not learn an idiom by learning dictionary
idioms have a history, they have a story, and usage
Eg. rains cats and dogs

Concise
Highly Expressive


The Illitrates of the 21st centuary will not be those who can not read and write
but those who can not learn, unlearn and relearn = Alwin Toffler

i want to work in a company which creates environment which allows me to say I don't know
in a team that makes absolutely safe to be honest, for me to say i want to learn

Environment Shapes Behaviour


There are risks and costs to a program of action, but they are far less than the long-range risks and costs of comfortable inaction - jFK

Design is good if its easier to change

YAGNI - You are not gonna Need it
    postpone things until they are really really needed

Cohesive code is narrow, focused, and does only one thing, hence changes less frequently
    Like things together, unlike things separate

Liskov's Substitution Principle
    use it only if there is substitutability
    Inheritance demands more from developers than Composition

Interface Segregation Principle
Clock implements TimeTeller, Alarm, Radio

so user one uses TimeTeller interface is only concerned about time details not Alarm or Radio

we are keeping interfaces separate for time, alarm, and radio

Functionl Programming = function composition and Lazy evaluation

Collectors mutablility is Local not shared hence safe

There is no point in optimizing the code for writing (or performance)
wen real cost is in reading
Mutability needs company, it often hangs around with bugs


These things add complexity: https://www.youtube.com/watch?v=nZcLHkORdHE&list=WL&index=17
    Too many moving parts
    Invisible changes
    uncontrolled Mutability
    lack of cohesion
    excessive dependencies
    technology infatuation
    low level concurrency
    imperative style
    entwinement: mixing two orthogonal stuff and putting them together
        Example: Manage external resources more deterministically,hence should not depend on finalize for external resource cleanup
        external resrouce cleanup is different than memory cleanup

a maintainable code is the gift we give to our future self


Java 8 sorting in streams
    based on firstName and secondName;

List<String> Max duplicates
    Highest Duplication

Normal Spring common question Singleton ko proto ke ander dala and reverse kiya to
Spring scopes

synchronized hashmap

DB
student and course table
    course 1 to 1 hai to foreign

Product id name type
Prodct type  ptId, ptName
metadata order id pid order date



