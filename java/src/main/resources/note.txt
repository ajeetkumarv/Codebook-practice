Java is pass by referenc or pass by value
    https://www.youtube.com/watch?v=-5NC5_sI-vQ

What is a POJO
    https://www.youtube.com/watch?v=oqPiEc2zNb0&list=WL&index=2&t=2s
    1) Can't extend or implement anything
    2) No external annotation

    this is usable itself without anything external

What is Java Bean
    https://www.youtube.com/watch?v=oqPiEc2zNb0&list=WL&index=2&t=2s
    1) has private members
    2) has no-args constructor (implicit is ok)
    3) has public getters and setters
    4) Must be serializable

Why Strings are Immutable
    https://www.youtube.com/watch?v=Bj9Mx_Lx3q4&list=WL&index=9
    https://stackoverflow.com/questions/390703/what-is-the-purpose-of-the-expression-new-string-in-java#:~:text=Initializes%20a%20newly%20created%20String,unnecessary%20since%20Strings%20are%20immutable.
    http://kjetilod.blogspot.com/2008/09/string-constructor-considered-useless.html
    new String() is actually Implementation Dependent, like Apache Harmony has different

Immutable classes in java
    Wrapper classes, String, LocalDateTime

Map contract
    1) if two objects are equals, must have same hashCode
    2) if hashCode is same, equals may not be same

Use least specific interface, this makes intentions clear and provides only what you need.

A fail-fast system doesn't continue with errors. it stops immediately. fail-safe are opposite bcz they work on the clone of data.
Fail-fast iterations => ConcurrentModificationException
Fail-safe iterations => NO ConcurrentModificationException

Streams
    Streams lets you process data in a expressive way. we can write code that is declarative, composable, parallelizable.
    It's an object on which we can define operations
    it doesn't change the data it processes.
    All the methods of stream that return stream are lazy

Lambda
    it's an object without Identity
    it is to be looked as block of code that can be moved around, not as a object on which we invoke methods.
    Types of lambda expression is FunctionalInterface

Duration => Hours, minutes, Seconds
Period => Year, month, days

In Normal case we use garbasge variable. it only purpose is to act as an intermediate throwaway container. in java 8 this
implementation detail is pushed into the library where it belongs.

Default methods helped evolve interfaces non intrusively

final
    As a programmer, I'd better know what i want to do, declaring intent and having the compiler enforce it on my behalf
    is a good thing.

Non-Reifiable Types
A reifiable type is a type whose type information is fully available at runtime. This includes primitives, non-generic types, raw types, and invocations of unbound wildcards.

Non-reifiable types are types where information has been removed at compile-time by type erasure — invocations of
    generic types that are not defined as unbounded wildcards. A non-reifiable type does not have all of
    its information available at runtime. Examples of non-reifiable types are List<String> and List<Number>;
    the JVM cannot tell the difference between these types at runtime. As shown in Restrictions on Generics,
    there are certain situations where non-reifiable types cannot be used: in an instanceof expression,
    for example, or as an element in an array.
    https://docs.oracle.com/javase/tutorial/java/generics/nonReifiableVarargsType.html#:~:text=A%20reifiable%20type%20is%20a,is%20fully%20available%20at%20runtime.&text=Non%2Dreifiable%20types%20are%20types,not%20defined%20as%20unbounded%20wildcards.

Heap Pollution (More on above link)
    Heap pollution occurs when a variable of a parameterized type refers to an object that is not of that parameterized type.
    This situation occurs if the program performed some operation that gives rise to an unchecked warning at compile-time.

Defensive copy
    is a technique to mitigate -ve effects of unintensional modifications of shared objects.

Immutability Advantages
    Simple to create, test, and use
    Automatically thread safe and have no synchronization issues
    Allow hashCode cache
    don't need to be defensively copied
    Don't need a copy constructor

Joshua Bloch
    Classes should be immutable unless there is a good reason to make them mutable. if not possible, limit their ability to mutate

Aggregation vs Composition
    Types can exist without car
    Room can't be without house (walls)

    Composition is strong association
    Aggregation is weak association

    Composition is part-of
    Aggregation is has-a

Lambda expression vs Annonymous class
    Ann class is for class declaration and Lambda is for method body
    Ann class generates an extra class wit $ and lambda uses invoke dynamics
    Ann class this represents ann class, this inside lambda refers to class
    Ann class can be used for > 1 abstract method, lambda only for SAM

Invoke Dynamics (Since 7)
    It is a new JVM instruction (opcode) which allows a compiler to generate code which calls
    methods with a looser specification than was previously possible --
    if you know what "duck typing" is, invokedynamic basically allows for duck typing.
    There's not too much you as a Java programmer can do with it; if you're a tool creator,
    though, you can use it to build more flexible, more efficient JVM-based languages.

    Before Java 7, the JVM only had four method invocation types:
    invokevirtual to call normal class methods,
    invokestatic to call static methods,
    invokeinterface to call interface methods, and
    invokespecial to call constructors or private methods.

-XX:+UseStringDeduplication
    StringDeduplicationAgeThreshold JVM setting default value 3
    -XX:+CompactStrings since java 9 on by default
    https://stackoverflow.com/questions/42080648/why-when-you-would-not-want-to-have-java-8-usestringdeduplication-enabled-in-jvm

https://stackoverflow.com/questions/586363/why-is-super-super-method-not-allowed-in-java?rq=1

    serial,
        Stop the world, single thread to GC
    parallel, default in <= Java 8 also known as throughput collector
        Stop the world, parallel threads to GC
    CMS, removed in 14.
        It's designed to eliminate the long pause associated with the full gc of parallel & serial collector.
        It use 1 or more gc threads to scan the old generation periodically, and discard unused objects,
        the pause is very short, but use more cpu time.
    G1GC,
        It's low pause / server style gc, mainly for large heap (> 4Gb).
        divides old gen into parts, clean old gen by copy from 1 part to another. thus less fragmented
    ZGC
    Shenandoah

Default garbage collectors:
    Java 7 - Parallel GC
    Java 8 - Parallel GC
    Java 9 - 15 - G1 GC
    -XX:+UseG1GC or -XX:+UseConcMarkSweepGC.

    https://stackoverflow.com/questions/33206313/default-garbage-collector-for-java-8
    https://backstage.forgerock.com/knowledge/kb/article/a75965340
    Parallel is also known as Throughput collector
    JEP 248: Make G1 the Default Garbage Collector
        http://openjdk.java.net/jeps/248
    https://docs.oracle.com/en/java/javase/11/gctuning/z-garbage-collector1.html#GUID-A5A42691-095E-47BA-B6DC-FB4E5FAA43D0

    https://www.baeldung.com/jvm-epsilon-gc-garbage-collector
    Epsilon GC or No-Op GC
    Algos
            Mark copy
            Mark Sweep

    Throuput
        avg time spent running code and running GC
        so 99% throuput means GC running 1% of time

    Generational Hypothesis
        Young Generation
        Old Generation
            Mark-Sweep-Compaction
    https://www.youtube.com/watch?v=2AZ0KKeXJSo Defog
    Ranjith ramachandran
    https://www.youtube.com/watch?v=UnaNQgzw4zY
        when -XX:MaxTenuringThreshold is reachied (i think 16) then objects are moved to old gen
    Minor run of GC in on Young Gen only
    Major run of GC goes through all spaces

jagged arrays

Before JDK 7, the pool was part of permgen space, and from JDK 7 to now, it is part of the main heap memory.

Thread is a worker, Runnable is the Job
Thread class itself implements Runnable
Once the thread is started, it can’t be started again.

Rob Pike
    https://rakhim.org/summary-of-concurrency-is-not-parallellism-a-talk-by-rob-pike/
    Parallelism is *doing* lot of things at once
    Concurrency is about *dealing* with a lot of things at once.

    The ideas are, obviously, related, but one is inherently associated with structure, the other is associated with execution.
    Concurrency is structuring things in a way that might allow parallelism to actually execute them simultaneously.
    But parallelism is not the goal of concurrency. The goal of concurrency is good structure.

https://www.baeldung.com/java-singleton
https://www.baeldung.com/java-singleton-double-checked-locking
    Conceptually, a singleton is a kind of global variable.
    In general, we know that global variables should be avoided — especially if their states are mutable.

https://wiki.sei.cmu.edu/confluence/display/java/TSM03-J.+Do+not+publish+partially+initialized+objects#:~:text=The%20Java%20memory%20model%20(JMM,publication%20of%20partially%20initialized%20objects.
https://stackoverflow.com/questions/45857765/partial-constructed-objects-in-the-java-memory-model
https://wiki.sei.cmu.edu/confluence/display/java/OBJ11-J.+Be+wary+of+letting+constructors+throw+exceptions


Since Java 16 it is possible
Regular Inner class can't have static declarations for members
Technically there I don't know of any reason why the language restricts the use of static elements for inner classes.
A nonstatic inner class can be emulated by using a normal class that takes the (formerly) enclosing instance as an
argument to the constructor. Of course there are many little differences when it comes to visibility rules an visibility scopes.

I presume it was a language design decision, mostly because statics in non-static inner classes
are confusing and non-intuitive to access (Outer.Inner.StaticMember).

Spliterator
  // Obtain a Spliterator.
  Spliterator<String> splitItr = myStream.spliterator();
  // Iterate the elements of the stream.
  while(splitItr.tryAdvance((n) -> System.out.println(n)));
  splitItr.forEachRemaining(n -> sout);

  Spliterator<String> splitItr = myStream.spliterator();
      // Now, split the first iterator.
      Spliterator<String> splitItr2 = splitItr.trySplit();
       // If splitItr could be split, use splitItr2 first.
      if(splitItr2 != null) {
        System.out.println("Output from splitItr2: ");
        splitItr2.forEachRemaining((n) -> System.out.println(n));
      }
      // Now, use the splitItr.
      System.out.println("\nOutput from splitItr: ");
      splitItr.forEachRemaining((n) -> System.out.println(n));

SynchronousQueue
    Direct Handoff or Size of 1(not really)
    No peek method
    no Iterate
    only for handoffs

    It requires consumer thread to be ready so that it can handoff directly

Collectors
    .toList
    .toMap
    .toSet
    .toUnmodifiableList
    .toUnmodifiableSet
    .toUnmodifiableMap
    .toConcurrentList
    .toConcurrentMap

Check Teeing in collectors this came with Java 12
if means collector, collector, combineThoseCollectors

https://www.baeldung.com/java-8-collectors


https://www.falkhausen.de/Java-10/java.util/Exceptions.html
https://rollbar.com/blog/java-exceptions-hierarchy-explained/

ZipError indicates a low-level JVM error and, although you may catch it just like any other exception,
there is a chance that the whole JVM is at that moment in such a state that it shouldn't continue to run.
Note that there is a separate ZipException for more regular sort of errors, like corrupt files, I/O errors etc.

Error
    ServiceConfigurationError (1.6)
    VirtualMachineError (CitiusTech - when SQLServer was taking 97% and error was Unable to create Java Virtual Machine)
        UnknownError
        InternalError
            ZipError (1.6)